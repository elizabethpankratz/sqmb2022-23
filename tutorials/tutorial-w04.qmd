---
title: "Tutorial 4"
editor: visual
execute: 
  eval: false
---

Let's pick up from where we left off last week.

In week 3, you learnt how to use ggplot2 to create bar charts and how to create different panels. Bar charts are great for categorical data.

This week you will learn how to make density and violin plots, which work very well with numeric data in combination of categorical data (for example, when you want to show values of a numeric variable across different groups).

Then, you will use the `brm()` function from the [brms](https://paul-buerkner.github.io/brms/) package to model continuous variables.

But first, let's read some data and transform it so that we can use it in the tutorial.

## Filtering and mutating data

### The `alb_vot` data

Let's play around with the Albanian VOT data we used in class.

The data comes from the paper by Coretta and colleagues, 2022. *Northern Tosk Albanian*. DOI: [10.1017/S0025100322000044](https://doi.org/10.1017/S0025100322000044). This is an IPA Illustration of Northern Tosk Albanian.

To download the file with the data right-click on the following link and download the file: [alb_vot.csv](../data/alb_vot.csv). (Note that tutorial files are also linked in the [Syllabus](../syllabus.qmd)). Remember to save the file in `data/` in the course project folder.

Create a new `.Rmd` file first, save it in `code/` and name it `tutorial-w04` (the extension `.Rmd` is added automatically!).

I leave to you creating title headings in your file as you please. Remember to to add `knitr::opts_knit$set(root.dir = here::here())` in the `setup` chunk and to attach the tidyverse.

Now you can create a new code chunk and read the `alb_vot.csv` file in R. Remember how to do this?

```{r}
#| label: alb-vot

alb_vot <- ...
```

### Mutating data

### Filtering data




## Plotting continuous variables

### Density plots

**Density plots show the distribution (i.e. the probability density) of the values of a continuous variable.**

Take for example the Reaction Times (`RT`) values in the *MAssive Lexical Decision* data set (`mald_1_1`).

```{r mald}
mald_1_1
```

To plot the density of a continuous variable, you can use the `density` geometry.

Fill in the following code to create a density plot.

```{r mald-dens, exercise=TRUE, exercise.setup = "tidy-load"}
mald_1_1 %>%
  ggplot(aes(RT)) +
  ...
```

::: {#mald-dens-hint}
Remember that all geometries start with `geom_`?
:::

### Make things cozy with a rug

The density line shows you a smoothed representation of the data distribution, but you might also want to see the raw data.

You can do so by adding the `rug` geometry.

```{r mald-dens-rug, exercise=TRUE, exercise.setup = "tidy-load"}
mald_1_1 %>%
  ggplot(aes(RT)) +
  geom_density() +
  ...
```

### Violin plots

An efficient way of showing the distribution of continuous variables depending on discrete groups (like `attitude`) are the so-called **violin plots**.

Go ahead and run the following code.

```{r pol-viol, exercise=TRUE}
polite %>%
  ggplot(aes(attitude, f0mn)) +
  geom_violin()
```

They are called violin plots because they look like violins!

### Lay over the raw data

You can lay over raw data on top of the violins.

To do so, you can use the `jitter` geometry. Fill the following code chunk and run it.

```{r pol-viol-jit, exercise=TRUE}
polite %>%
  ggplot(aes(attitude, f0mn)) +
  geom_violin() +
  ...
```

That doesn't look great right? The points are spread too widely.

We can fix that by specifying the argument `width` in the jitter geometry something smaller than `0.5`. Try a few values until you think it looks better.

```{r pol-viol-jit-2, exercise=TRUE}
polite %>%
  ggplot(aes(attitude, f0mn)) +
  geom_violin() +
  ...
```

```{r pol-viol-jit-2-hint}
geom_jitter(width = ...)
```

Note that the order between the violin and jitter geoms is important. If you add the jitter geometry before the violin geometry, the violins will just cover up the jittered points (see why it is called "layered" grammar of graphics?).

### Let's add some colour

Let's **fill** the violins with colour. For now, just colour the violins depending on `attitude`

```{r pol-colour, exercise=TRUE}
polite %>%
  ggplot(aes(attitude, f0mn, ...)) +
  geom_violin()
```

```{r pol-colour-hint}
fill = ...
```

Not bad! But maybe we can improve by making the fill a bit transparent?

You can achieve that with the `alpha` argument in `geom_violin()`, which takes a number between 0 (completely transparent) and 1 (completely opaque).

Add it to the code above to make the fill transparent. Try different values until you are satisfied with the output.

### Separate the data by gender

In the previous section we have filled the violins with colours depending on `attitude`. This helps making the plot somewhat more appealing, but colour there doesn't add information to the plot: attitude is already marked by the *x*-axis, so filling by attitude is a bit redundant.

Instead, we can use the fill argument to separate the data into further groups based on other variables in the data.

Go ahead and separate the data by `gender` using the `fill` argument.

```{r pol-colour-gen, exercise=TRUE}

polite %>%
  ggplot(aes(attitude, f0mn, ...)) +
  geom_violin()
```

What if we want to move the colour legend to the bottom of the plot?

<!--# Need to double check this and make it match the previous exercise. -->

In `ggplot2`, we control the position of the legend by modifying an elements of the `theme` option. (If this seems arbitrary, you're not wrong. Eventually you'll memorise quirky `ggplot2` features like this, and until then, you can figure it out by searching "How do I change legend position in ggplot" and some kind soul on the internet will tell you.)

Check out the documentation of `theme` by typing `?theme` in the RStudio Console and press ENTER. Search for the word `position`.

::: callout-important
#### Question

**Which of the following moves the legend to the bottom of the plot?**

1.  `legend("bottom")`
2.  `theme(legend.position = "bottom")`
3.  `theme(legend.bottom)`
:::

To check, try replacing the first `...` in the code below with the `y =` specification you used above, and the second `...` with the correct way of moving the legend to the bottom of the plot. Run the code to see if you're right!

```{r}
#| label: status-stacked-legend-bottom
#| eval: false

ggplot(
  data = glot_status,
  mapping = aes(x = Macroarea, ...)
) +
  geom_bar() +
  ...
```

## Legends and labels

### Positioning the legend

The position of the legend can be set with the `legend.position` argument in `theme()`.

Move the legend to the `"bottom"`.

```{r}
#| label: status-legend
#| eval: false

ggplot(
  data = glot_status,
  mapping = aes(x = Macroarea, fill = status)
) +
  geom_bar() +
  ...
```

### Plot titles and labels

The `labs()` function allows you to set the plot title, subtitle, axis labels and more.

Since these are strings (i.e. text), they must be quoted with `"`.

```{r}
#| label: status-title

ggplot(
  data = glot_status,
  mapping = aes(x = Macroarea, fill = status)
) +
  geom_bar() +
  labs(
    title = "Number of languages by macro-area and\nAggregated Endangerement Status"
  )
```

NOTE: We use `\n` to split the title into two lines, so that it fits the plot. `\n` simply means "**n**ew line".

### Axis labels

To change the axis labels, you specify a string for `x` and `y`.

I have changed the `x` label here below. Go ahead and change `y` to `"Number of languages"`.

```{r}
#| label: status-labs
#| eval: false

ggplot(
  data = glot_status,
  mapping = aes(x = Macroarea, fill = status)
) +
  geom_bar() +
  labs(
    # We use \n to split the title into two lines. \n means "new line"
    title = "Number of languages by macro-area and\nAggregated Endangerement Status",
    x = "Language macro-area",
    ...
  )
```
